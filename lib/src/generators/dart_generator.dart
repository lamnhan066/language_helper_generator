import 'dart:convert';
import 'dart:io';

import 'package:analyzer/dart/analysis/utilities.dart';
import 'package:analyzer/dart/ast/ast.dart';
import 'package:language_helper_generator/src/models/data_type.dart';
import 'package:language_helper_generator/src/models/parsed_data.dart';
import 'package:language_helper_generator/src/utils/todo_comment.dart';
import 'package:lite_logger/lite_logger.dart';
import 'package:path/path.dart' as p;

void exportDart(
  Map<String, List<ParsedData>> data,
  String output,
  List<String> languageCodes, {
  bool includeInvalid = true,
  Set<String> ignoreTodoCodes = const <String>{},
  bool dartFormat = true,
  bool dartFix = true,
  bool fvm = false,
  LiteLogger? logger,
}) {
  logger ??= LiteLogger(minLevel: LogLevel.debug);
  logger.log('Exporting Dart files...', LogLevel.step);

  final date = DateTime.now().toIso8601String();
  _createCodesFile(languageCodes, output: output, date: date, logger: logger);
  _createLanguageBoilerplateFiles(
    data,
    languageCodes,
    output: output,
    includeInvalid: includeInvalid,
    ignoreTodoCodes: ignoreTodoCodes,
    date: date,
    logger: logger,
  );

  if (dartFormat) {
    logger.log('Running dart format on $output...', LogLevel.step);
    if (fvm) {
      Process.runSync('fvm', ['dart', 'format', output]);
    } else {
      Process.runSync('dart', ['format', output]);
    }
    logger.log('Dart format complete.', LogLevel.success);
  }

  if (dartFix) {
    logger.log('Running dart fix --apply on $output...', LogLevel.step);
    if (fvm) {
      Process.runSync('fvm', ['dart', 'fix', output, '--apply']);
    } else {
      Process.runSync('dart', ['fix', output, '--apply']);
    }
    logger.log('Dart fix complete.', LogLevel.success);
  }

  logger.log('Dart export completed.', LogLevel.success);
}

/// Create `codes.dart`
void _createCodesFile(
  List<String> languageCodes, {
  required String output,
  required String date,
  required LiteLogger logger,
}) {
  logger.log('Starting creation of `codes.dart` at $output...', LogLevel.step);

  final desFile = File(p.join(output, 'codes.dart'));

  if (desFile.existsSync()) {
    logger.log(
      'File `codes.dart` already exists. Recreating...',
      LogLevel.info,
    );
  } else {
    logger.log(
      'File `codes.dart` does not exist. Creating new file...',
      LogLevel.info,
    );
  }

  desFile.createSync(recursive: true);
  logger.log('Directory for `codes.dart` ensured.', LogLevel.info);

  final entriesBuffer = StringBuffer();
  final dedupedCodes = <String>{
    for (final raw in languageCodes)
      if (raw.trim().isNotEmpty) raw.trim(),
  };
  final normalizedCodes = dedupedCodes.toList(growable: false);
  final activeCodes =
      normalizedCodes.isEmpty ? <String>['en'] : normalizedCodes;
  final languageImportList = <String>[];
  final languageImportSet = <String>{};
  final seenEnumNames = <String>{};

  for (final code in activeCodes) {
    final enumName = _languageEnumName(code);
    if (enumName == null || !seenEnumNames.add(enumName)) continue;
    final constName = _languageConstName(code);
    if (constName == 'languageData') continue;
    entriesBuffer.writeln('  LanguageCodes.$enumName: () => $constName,');
    if (languageImportSet.add(code)) {
      languageImportList.add(code);
    }
  }

  if (entriesBuffer.isEmpty) {
    final constName = _languageConstName('en');
    entriesBuffer.writeln('  LanguageCodes.en: () => $constName,');
    if (languageImportSet.add('en')) {
      languageImportList.add('en');
    }
  }

  final fileBuffer =
      StringBuffer()
        ..writeln(
          '//==============================================================================',
        )
        ..writeln('// Generated Date: $date')
        ..writeln('//')
        ..writeln(
          '// Generated by language_helper. Please do not modify by hand',
        )
        ..writeln(
          '//==============================================================================',
        )
        ..writeln()
        ..writeln('// Keeps format for the parser')
        ..writeln('// ignore_for_file: always_use_package_imports')
        ..writeln()
        ..writeln("import 'package:language_helper/language_helper.dart';")
        ..writeln();

  for (final code in languageImportList) {
    fileBuffer.writeln("import 'data/$code.dart';");
  }

  fileBuffer
    ..writeln()
    ..writeln('final LazyLanguageData languageData = {')
    ..write(entriesBuffer.toString())
    ..writeln('};');

  desFile.writeAsStringSync(fileBuffer.toString());

  logger.log('Successfully created `codes.dart`.', LogLevel.success);
}

void _createLanguageBoilerplateFiles(
  Map<String, List<ParsedData>> data,
  List<String> languageCodes, {
  required String output,
  bool includeInvalid = true,
  Set<String> ignoreTodoCodes = const <String>{},
  required String date,
  required LiteLogger logger,
}) {
  logger.log(
    'Starting creation of language boilerplate files at $output...',
    LogLevel.step,
  );
  if (languageCodes.isEmpty) {
    logger.log(
      'No language codes provided for boilerplate file creation. Skipping.',
      LogLevel.warning,
    );
    return;
  }

  final languagesDir = Directory(p.join(output, 'data'));
  logger.log('Ensuring directory exists: ${languagesDir.path}', LogLevel.info);
  languagesDir.createSync(recursive: true);
  logger.log('Directory ensured.', LogLevel.info);

  for (final code in languageCodes) {
    if (code.isEmpty) {
      logger.log('Skipping empty language code.', LogLevel.warning);
      continue;
    }
    logger.log('Processing language code: $code', LogLevel.info);
    final file = File(p.join(languagesDir.path, '$code.dart'));
    logger.log(
      'Reading existing language file for $code: ${file.path}',
      LogLevel.debug,
    );
    final existing = _readExistingDartLanguageFile(file, logger);
    logger.log(
      'Finished reading existing language file for $code.',
      LogLevel.debug,
    );
    final seenTexts = <ParsedData>{};
    final buffer = StringBuffer();

    buffer
      ..writeln(
        '//==============================================================================',
      )
      ..writeln('// Generated Date: $date')
      ..writeln('//')
      ..writeln(
        '// Generated by language_helper. Only the values will persist across regenerations.\n'
        '// Valid value types are limited to `String` or `LanguageCodes`.',
      )
      ..writeln(
        '//==============================================================================',
      )
      ..writeln()
      ..writeln('// Keeps format for the parser')
      ..writeln('// ignore_for_file: prefer_single_quotes');

    if (existing.imports.isNotEmpty) {
      buffer.writeln();
      for (final import in existing.imports) {
        buffer.writeln(import);
      }
      buffer.writeln();
    }

    buffer
      ..writeln()
      ..writeln(
        '${existing.declarationKeyword} ${_languageConstName(code)} = <String, dynamic>{',
      );

    data.forEach((filePath, values) {
      final pathKey = '@path_$filePath';
      final pathKeyLiteral = _stringLiteral(pathKey);
      final pathEntry = existing.entries[pathKey];
      final pathValueExpression = pathEntry?.expression ?? _stringLiteral('');

      buffer
        ..writeln()
        ..writeln(
          '  ///===========================================================================',
        )
        ..writeln('  /// Path: $filePath')
        ..writeln(
          '  ///===========================================================================',
        );

      buffer.writeln('  $pathKeyLiteral: $pathValueExpression,');

      for (final parsed in values) {
        final key = parsed.noFormatedText;
        final keyLiteral = _stringLiteral(key);
        final existingEntry = existing.entries[key];
        final valueExpression = existingEntry?.expression ?? keyLiteral;
        final existingStringValue = existingEntry?.stringValue;

        String commentPrefix = '';
        String commentSuffix = '';
        bool commentOut = false;

        if (parsed.type != DataType.normal) {
          commentOut = true;
          commentPrefix = '// ';
          commentSuffix = '  // ${parsed.type.text}';
        } else if (!seenTexts.add(parsed)) {
          commentOut = true;
          commentPrefix = '// ';
          commentSuffix = '  // Duplicated';
        }

        if (commentOut) {
          if (includeInvalid) {
            buffer.writeln(
              '  $commentPrefix$keyLiteral: $valueExpression,$commentSuffix',
            );
          }
          continue;
        }

        final hasExistingTodo = existing.todoKeys.contains(key);
        final isPlaceholder =
            existingEntry == null ||
            (existingStringValue != null &&
                (existingStringValue.isEmpty || existingStringValue == key));
        final needsTodo =
            (existingEntry == null || (hasExistingTodo && isPlaceholder)) &&
            !key.startsWith('@path_');

        if (needsTodo && !ignoreTodoCodes.contains(code)) {
          buffer.writeln('  ${todoComment(code)}');
        }
        buffer.writeln('  $keyLiteral: $valueExpression,');
      }
    });

    buffer.writeln('};');

    logger.log('Writing content to file: ${file.path}', LogLevel.info);
    file.writeAsStringSync(buffer.toString());
    logger.log(
      'Successfully created boilerplate file for language code: $code',
      LogLevel.success,
    );
  }
  logger.log(
    'Finished creating all language boilerplate files.',
    LogLevel.success,
  );
}

_ExistingLanguageFile _readExistingDartLanguageFile(
  File file,
  LiteLogger logger,
) {
  logger.log(
    'Attempting to read existing Dart language file: ${file.path}',
    LogLevel.debug,
  );
  if (!file.existsSync()) {
    logger.log(
      'File does not exist: ${file.path}. Returning empty _ExistingLanguageFile.',
      LogLevel.info,
    );
    return _ExistingLanguageFile();
  }

  final content = file.readAsStringSync();
  logger.log('File content read for: ${file.path}.', LogLevel.debug);
  final parseResult = parseString(content: content);
  final unit = parseResult.unit;
  logger.log('File parsed into AST unit.', LogLevel.debug);

  final imports =
      unit.directives
          .whereType<ImportDirective>()
          .map((directive) => directive.toSource())
          .toList();
  logger.log('Extracted ${imports.length} imports.', LogLevel.debug);

  final entries = <String, _ExistingEntry>{};
  String declarationKeyword = 'const';
  logger.log(
    'Starting to extract existing entries and declaration keyword.',
    LogLevel.debug,
  );

  for (final declaration in unit.declarations) {
    if (declaration is! TopLevelVariableDeclaration) continue;
    final variableList = declaration.variables;
    final keyword = variableList.keyword?.lexeme;

    for (final variable in variableList.variables) {
      final initializer = variable.initializer;
      if (initializer is! SetOrMapLiteral) continue;
      final hasMapEntry = initializer.elements.any(
        (element) => element is MapLiteralEntry,
      );
      if (!hasMapEntry) continue;

      if (keyword == 'final') {
        declarationKeyword = 'final';
      } else if (keyword == 'const') {
        declarationKeyword = 'const';
      }

      for (final element in initializer.elements) {
        if (element is! MapLiteralEntry) continue;
        final keyLiteral = element.key;
        if (keyLiteral is! StringLiteral) continue;
        final key = keyLiteral.stringValue;
        if (key == null) continue;

        final value = element.value;
        final expression = value.toSource();
        String? stringValue;
        if (value is StringLiteral) {
          stringValue = value.stringValue;
        }

        entries[key] = _ExistingEntry(
          expression: expression,
          stringValue: stringValue,
        );
      }

      break;
    }
  }

  logger.log(
    'Finished extracting existing entries. Declaration keyword: $declarationKeyword.',
    LogLevel.debug,
  );

  final todoKeys = <String>{};
  final keyRegex = RegExp(r'"((?:[^"\\]|\\.)*)"\s*:');
  bool pendingTodoComment = false;
  logger.log(
    'Starting to identify TODO comments and associated keys.',
    LogLevel.debug,
  );

  for (final rawLine in content.split('\n')) {
    final trimmed = rawLine.trim();
    if (trimmed.isEmpty) continue;

    final containsTodo = containsTodoComment(trimmed);
    final isCommentLine = trimmed.startsWith('//');

    if (isCommentLine) {
      if (containsTodo) pendingTodoComment = true;
      continue;
    }

    var line = trimmed;
    if (containsTodo) {
      line = line.split('//').first.trimRight();
    }

    final match = keyRegex.firstMatch(line);
    if (match == null) continue;

    final key = json.decode('"${match.group(1)!}"') as String;
    if (containsTodo || pendingTodoComment) {
      todoKeys.add(key);
      pendingTodoComment = false;
    } else {
      pendingTodoComment = false;
    }
  }

  logger.log(
    'Finished identifying TODO comments. Found ${todoKeys.length} TODO keys.',
    LogLevel.debug,
  );

  return _ExistingLanguageFile(
    entries: entries,
    todoKeys: todoKeys,
    declarationKeyword: declarationKeyword,
    imports: imports,
  );
}

String _stringLiteral(String value) => json.encode(value);

String? _languageEnumName(String code) {
  final sanitized = code.replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_');
  final parts = sanitized
      .split('_')
      .where((part) => part.isNotEmpty)
      .map((part) => part.toLowerCase());
  final enumName = parts.join('_');
  if (enumName.isEmpty) return null;
  if (RegExp(r'^[0-9]').hasMatch(enumName)) return null;
  return enumName;
}

String _languageConstName(String code) {
  final sanitized = code.replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_');
  if (sanitized.isEmpty) return 'languageData';

  final parts = sanitized
      .split('_')
      .where((part) => part.isNotEmpty)
      .toList(growable: false);
  if (parts.isEmpty) return 'languageData';

  final buffer = StringBuffer(parts.first.toLowerCase());
  for (var i = 1; i < parts.length; i++) {
    final part = parts[i];
    if (part.isEmpty) continue;
    buffer.write(part.substring(0, 1).toUpperCase());
    if (part.length > 1) {
      buffer.write(part.substring(1).toLowerCase());
    }
  }

  buffer.write('LanguageData');
  return buffer.toString();
}

class _ExistingLanguageFile {
  final Map<String, _ExistingEntry> entries;
  final Set<String> todoKeys;
  final String declarationKeyword;
  final List<String> imports;

  _ExistingLanguageFile({
    Map<String, _ExistingEntry>? entries,
    Set<String>? todoKeys,
    String? declarationKeyword,
    List<String>? imports,
  }) : entries = entries ?? <String, _ExistingEntry>{},
       todoKeys = todoKeys ?? <String>{},
       declarationKeyword = declarationKeyword ?? 'const',
       imports = imports ?? <String>[];
}

class _ExistingEntry {
  final String expression;
  final String? stringValue;

  _ExistingEntry({required this.expression, this.stringValue});
}
